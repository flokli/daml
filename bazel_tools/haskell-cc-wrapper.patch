diff --git a/haskell/BUILD.bazel b/haskell/BUILD.bazel
index f08921a..b311010 100644
--- a/haskell/BUILD.bazel
+++ b/haskell/BUILD.bazel
@@ -2,6 +2,10 @@ load(
     "@io_tweag_rules_haskell//haskell:haskell.bzl",
     "haskell_toolchain_libraries",
 )
+load(
+    "@io_tweag_rules_haskell//haskell:private/cc_wrapper.bzl",
+    "cc_wrapper",
+)
 
 exports_files(
     glob(["*.bzl"]) + [
@@ -10,7 +14,7 @@ exports_files(
         "private/coverage_wrapper.sh.tpl",
         "private/ghci_repl_wrapper.sh",
         "private/haddock_wrapper.sh.tpl",
-        "private/osx_cc_wrapper.sh.tpl",
+        "private/cc_wrapper.py.tpl",
         "private/pkgdb_to_bzl.py",
     ],
 )
@@ -21,6 +25,11 @@ exports_files(
     visibility = ["//tests/unit-tests:__pkg__"],
 )
 
+cc_wrapper(
+    name = "cc_wrapper",
+    visibility = ["//visibility:public"],
+)
+
 py_binary(
     name = "pkgdb_to_bzl",
     srcs = ["private/pkgdb_to_bzl.py"],
diff --git a/haskell/cc.bzl b/haskell/cc.bzl
index aa619d9..04f406f 100644
--- a/haskell/cc.bzl
+++ b/haskell/cc.bzl
@@ -20,6 +20,7 @@ CcInteropInfo = provider(
         # See the following for why this is needed:
         # https://stackoverflow.com/questions/52769846/custom-c-rule-with-the-cc-common-api
         "files": "Files for all tools (input to any action that uses tools)",
+        "manifests": "Input manifests for all tools (input to any action that uses tools)",
         "hdrs": "CC headers",
         "cpp_flags": "Preprocessor flags",
         "compiler_flags": "Flags for compilation",
@@ -99,22 +100,10 @@ def cc_interop_info(ctx):
 
     # Generate cc wrapper script on Darwin that adjusts load commands.
     hs_toolchain = ctx.toolchains["@io_tweag_rules_haskell//haskell:toolchain"]
-    if hs_toolchain.is_darwin:
-        cc_wrapper = ctx.actions.declare_file("osx_cc_wrapper")
-        cc = cc_wrapper.path
-        ctx.actions.expand_template(
-            template = hs_toolchain.osx_cc_wrapper_tpl,
-            output = cc_wrapper,
-            substitutions = {
-                "%{cc}": cc_toolchain.compiler_executable(),
-            },
-        )
-        cc_files = ctx.files._cc_toolchain + [
-            cc_wrapper,
-        ]
-    else:
-        cc = cc_toolchain.compiler_executable()
-        cc_files = ctx.files._cc_toolchain
+    cc_wrapper = hs_toolchain.cc_wrapper
+    cc = cc_wrapper.executable.path
+    cc_files = ctx.files._cc_toolchain + cc_wrapper.inputs.to_list()
+    cc_manifests = cc_wrapper.manifests
 
     # XXX Workaround https://github.com/bazelbuild/bazel/issues/6876.
     linker_flags = [flag for flag in linker_flags if flag not in ["-shared"]]
@@ -139,6 +128,7 @@ def cc_interop_info(ctx):
     return CcInteropInfo(
         tools = struct(**tools),
         files = cc_files,
+        manifests = cc_manifests,
         hdrs = hdrs.to_list(),
         cpp_flags = cpp_flags,
         include_args = include_args,
diff --git a/haskell/private/actions/compile.bzl b/haskell/private/actions/compile.bzl
index 9c10fcf..95383ec 100644
--- a/haskell/private/actions/compile.bzl
+++ b/haskell/private/actions/compile.bzl
@@ -231,10 +231,6 @@ def _compilation_defaults(hs, cc, java, dep_info, plugin_dep_info, cc_info, srcs
 
     compile_flags += cc.include_args
 
-    locale_archive_depset = (
-        depset([hs.toolchain.locale_archive]) if hs.toolchain.locale_archive != None else depset()
-    )
-
     # This is absolutely required otherwise GHC doesn't know what package it's
     # creating `Name`s for to put them in Haddock interface files which then
     # results in Haddock not being able to find names for linking in
@@ -316,7 +312,7 @@ def _compilation_defaults(hs, cc, java, dep_info, plugin_dep_info, cc_info, srcs
     )
 
     # Transitive library dependencies for runtime.
-    (ghci_extra_libs, ghc_env) = get_ghci_extra_libs(hs, cc_info, dynamic = False)
+    (ghci_extra_libs, ghc_env) = get_ghci_extra_libs(hs, cc_info)
 
     return struct(
         args = args,
@@ -338,7 +334,6 @@ def _compilation_defaults(hs, cc, java, dep_info, plugin_dep_info, cc_info, srcs
             pkg_info_inputs,
             ghci_extra_libs,
             java.inputs,
-            locale_archive_depset,
             preprocessors.inputs,
             plugin_tool_inputs,
             depset([optp_args_file]),
diff --git a/haskell/private/actions/link.bzl b/haskell/private/actions/link.bzl
index f36759b..d72af66 100644
--- a/haskell/private/actions/link.bzl
+++ b/haskell/private/actions/link.bzl
@@ -352,15 +352,10 @@ def link_library_dynamic(hs, cc, dep_info, cc_info, extra_srcs, objects_dir, my_
     )
     args.add_all(pkg_info_args)
 
-    # When linking a dynamic library we still collect static libraries for
-    # dependencies where possible. This is so that a final binary that depends
-    # on this dynamic library, is linked statically itself, will not fail at
-    # link time due to missing transitive dynamic library dependencies. In this
-    # case transitive dependencies will still be linked in statically.
     (cache_file, static_libs, dynamic_libs) = create_link_config(
         hs = hs,
         cc_info = cc_info,
-        dynamic = False,
+        dynamic = True,
         pic = True,
         binary = dynamic_library,
         args = args,
diff --git a/haskell/private/actions/repl.bzl b/haskell/private/actions/repl.bzl
index ab7bf2f..c539295 100644
--- a/haskell/private/actions/repl.bzl
+++ b/haskell/private/actions/repl.bzl
@@ -116,6 +116,7 @@ def build_haskell_repl(
         substitutions = {
             "{ENV}": render_env(ghc_env),
             "{TOOL}": hs.tools.ghci.path,
+            "{CC}": hs.toolchain.cc_wrapper.executable.path,
             "{ARGS}": " ".join(
                 [
                     "-ghci-script",
@@ -172,5 +173,6 @@ def build_haskell_repl(
         pkg_info_inputs,
         ghci_extra_libs,
         set.to_depset(hs_info.source_files),
+        hs.toolchain.cc_wrapper.runfiles.files,
     ])
     ln(hs, repl_file, output, extra_inputs)
diff --git a/haskell/private/actions/runghc.bzl b/haskell/private/actions/runghc.bzl
index ca61457..201a092 100644
--- a/haskell/private/actions/runghc.bzl
+++ b/haskell/private/actions/runghc.bzl
@@ -87,6 +87,7 @@ def build_haskell_runghc(
         substitutions = {
             "{ENV}": render_env(ghc_env),
             "{TOOL}": hs.tools.runghc.path,
+            "{CC}": hs.toolchain.cc_wrapper.executable.path,
             "{ARGS}": " ".join([shell.quote(a) for a in runcompile_flags]),
         },
         is_executable = True,
@@ -105,5 +106,6 @@ def build_haskell_runghc(
         pkg_info_inputs,
         ghci_extra_libs,
         set.to_depset(hs_info.source_files),
+        hs.toolchain.cc_wrapper.runfiles.files,
     ])
     ln(hs, runghc_file, output, extra_inputs)
diff --git a/haskell/private/cc_wrapper.bzl b/haskell/private/cc_wrapper.bzl
new file mode 100644
index 0000000..d135d2e
--- /dev/null
+++ b/haskell/private/cc_wrapper.bzl
@@ -0,0 +1,62 @@
+load("@bazel_tools//tools/cpp:toolchain_utils.bzl", "find_cpp_toolchain")
+load("@bazel_tools//tools/build_defs/cc:action_names.bzl", "ACTION_NAMES")
+
+def _cc_wrapper_impl(ctx):
+    cc_toolchain = find_cpp_toolchain(ctx)
+    feature_configuration = cc_common.configure_features(
+        ctx = ctx,
+        cc_toolchain = cc_toolchain,
+        requested_features = ctx.features,
+        unsupported_features = ctx.disabled_features,
+    )
+    cc = cc_common.get_tool_for_action(
+        feature_configuration = feature_configuration,
+        action_name = ACTION_NAMES.c_compile,
+    )
+    cc_wrapper = ctx.actions.declare_file(ctx.label.name + ".py")
+    ctx.actions.expand_template(
+        template = ctx.file.template,
+        output = cc_wrapper,
+        is_executable = True,
+        substitutions = {
+            "{:cc:}": cc,
+            "{:workspace:}": ctx.workspace_name,
+        },
+    )
+    return [DefaultInfo(
+        files = depset([cc_wrapper]),
+        runfiles = ctx.runfiles(
+            transitive_files = cc_toolchain.all_files,
+            collect_data = True,
+        ),
+    )]
+
+_cc_wrapper = rule(
+    implementation = _cc_wrapper_impl,
+    attrs = {
+        "template": attr.label(
+            allow_single_file = True,
+            default = Label("@io_tweag_rules_haskell//haskell:private/cc_wrapper.py.tpl"),
+        ),
+        "_cc_toolchain": attr.label(
+            default = Label("@bazel_tools//tools/cpp:current_cc_toolchain"),
+        ),
+    },
+    fragments = ["cpp"],
+)
+
+def cc_wrapper(name, template = None, **kwargs):
+    _cc_wrapper(
+        name = name + "-source",
+        template = template,
+    )
+    native.py_binary(
+        name = name,
+        srcs = [name + "-source"],
+        main = name + "-source.py",
+        python_version = "PY3",
+        deps = [
+            "@bazel_tools//tools/python/runfiles",
+        ],
+        **kwargs
+    )
diff --git a/haskell/private/cc_wrapper.py.tpl b/haskell/private/cc_wrapper.py.tpl
new file mode 100644
index 0000000..ffdb9f6
--- /dev/null
+++ b/haskell/private/cc_wrapper.py.tpl
@@ -0,0 +1,829 @@
+#!/usr/bin/env python3
+"""CC toolchain wrapper
+
+Usage: cc_wrapper [ARG]...
+
+Wraps the C compiler of the Bazel CC toolchain. Transforms arguments to work
+around limitations of Bazel and GHC and passes those via response file to the C
+compiler.
+
+- Shortens library search paths to stay below maximum path length on Windows.
+
+    GHC generates library search paths that contain redundant up-level
+    references (..). This can exceed the maximum path length on Windows, which
+    will cause linking failures. This wrapper shortens library search paths to
+    avoid that issue.
+
+- Shortens rpaths and load commands on macOS.
+
+    The rpaths and load commands generated by GHC and Bazel can quickly exceed
+    the MACH-O header size limit on macOS. This wrapper shortens and combines
+    rpaths and load commands to avoid exceeding that limit.
+
+- Finds .so files if only .dylib are searched on macOS.
+
+    Bazel's cc_library will generate .so files for dynamic libraries even on
+    macOS. GHC strictly expects .dylib files on macOS. This wrapper hooks into
+    gcc's --print-file-name feature to work around this mismatch in file
+    extension.
+
+"""
+
+from bazel_tools.tools.python.runfiles import runfiles as bazel_runfiles
+from contextlib import contextmanager
+import glob
+import itertools
+import os
+import platform
+import shlex
+import subprocess
+import sys
+import tempfile
+
+WORKSPACE = "{:workspace:}"
+CC = "{:cc:}"
+INSTALL_NAME_TOOL = "/usr/bin/install_name_tool"
+OTOOL = "/usr/bin/otool"
+
+
+def main():
+    parsed = Args(load_response_files(sys.argv[1:]))
+
+    if parsed.linking:
+        link(parsed.output, parsed.libraries, parsed.rpaths, parsed.args)
+    elif parsed.printing_file_name:
+        print_file_name(parsed.print_file_name, parsed.args)
+    else:
+        run_cc(parsed.args, exit_on_error=True)
+
+
+# --------------------------------------------------------------------
+# Parse arguments
+
+
+class Args:
+    """Parsed command-line arguments.
+
+    Attrs:
+      args: The collected and transformed arguments.
+
+      linking: The action is linking.
+      printing_file_name: The action is print-file-name.
+
+      output: The output binary or library when linking.
+      library_paths: The library search paths when linking.
+      libraries: The required libraries when linking.
+      rpaths: The provided rpaths when linking.
+
+      print_file_name: The queried file name on print-file-name.
+
+    """
+    LINK = "link"
+    COMPILE = "compile"
+    PRINT_FILE_NAME = "print-file-name"
+
+    def __init__(self, args):
+        """Parse the given arguments into an Args object.
+
+        - Shortens library search paths.
+        - Detects the requested action.
+        - Keeps rpath arguments for further processing when linking.
+        - Keeps print-file-name arguments for further processing.
+
+        Args:
+          args: Iterable over command-line arguments.
+
+        """
+        self.action = Args.LINK
+        self.print_file_name = None
+        self.libraries = []
+        self.library_paths = []
+        self.rpaths = []
+        self.output = None
+        self._prev_ld_arg = None
+
+        self.args = list(self._handle_args(args))
+
+        if not self.linking:
+            # We don't expect rpath arguments if not linking, however, just in
+            # case, forward them if we don't mean to modify them.
+            self.args.extend(rpath_args(self.rpaths))
+
+    @property
+    def linking(self):
+        """Whether this is a link invocation."""
+        return self.action == Args.LINK and self.output is not None
+
+    @property
+    def compiling(self):
+        """Whether this is a compile invocation."""
+        return self.action == Args.COMPILE
+
+    @property
+    def printing_file_name(self):
+        """Whether this is a print-file-name invocation."""
+        return self.action == Args.PRINT_FILE_NAME and self.print_file_name is not None
+
+    def _handle_args(self, args):
+        """Argument handling pipeline.
+
+        Args:
+          args: Iterable, command-line arguments.
+
+        Yields:
+          Transformed command-line arguments.
+
+        """
+        args = iter(args)
+        for arg in args:
+            out = []
+            # Poor man's pattern matching: Each handler function takes the
+            # current argument, the stream of up-coming arguments, and a
+            # reference to the list of arguments to forward. The handler must
+            # return True if it consumes the argument, and return False if
+            # another handler should consume the argument.
+            if self._handle_output(arg, args, out):
+                pass
+            elif self._handle_library(arg, args, out):
+                pass
+            elif self._handle_library_path(arg, args, out):
+                pass
+            elif self._handle_linker_arg(arg, args, out):
+                pass
+            elif self._handle_print_file_name(arg, args, out):
+                pass
+            elif self._handle_compile(arg, args, out):
+                pass
+            else:
+                yield arg
+
+            for out_arg in out:
+                yield out_arg
+
+    def _handle_output(self, arg, args, out):
+        if arg == "-o":
+            # Remember the output filename.
+            self.output = next(args)
+            out.extend(["-o", self.output])
+            return True
+        else:
+            return False
+
+    def _handle_library(self, arg, args, out):
+        if arg == "-l" or arg == "--library":
+            library = next(args)
+        elif arg.startswith("-l"):
+            library = arg[2:]
+        elif arg.startswith("--library="):
+            library = arg[len("--library="):]
+        else:
+            return False
+
+        # Remember the required libraries.
+        self.libraries.append(library)
+        out.append("-l{}".format(library))
+
+        return True
+
+    def _handle_library_path(self, arg, args, out):
+        if arg == "-L" or arg == "--library-path":
+            library_path = next(args)
+        elif arg.startswith("-L"):
+            library_path = arg[2:]
+        elif arg.startswith("--library-path="):
+            library_path = arg[len("--library-path="):]
+        else:
+            return False
+
+        # Shorten the library search paths. On Windows library search paths may
+        # exceed the maximum path length.
+        shortened = shorten_path(library_path)
+        # Remember the library search paths.
+        self.library_paths.append(shortened)
+        out.append("-L{}".format(shortened))
+
+        return True
+
+    def _handle_linker_arg(self, arg, args, out):
+        if arg == "-Xlinker":
+            ld_arg = next(args)
+            if self._prev_ld_arg is None:
+                if ld_arg == "-rpath":
+                    self._prev_ld_arg = ld_arg
+                else:
+                    out.extend(["-Xlinker", ld_arg])
+            elif self._prev_ld_arg == "-rpath":
+                self._prev_ld_arg = None
+                self._handle_rpath(ld_arg, out)
+            else:
+                # This indicates a programmer error and should not happen.
+                raise RuntimeError("Unhandled _prev_ld_arg '{}'.".format(self._prev_ld_arg))
+            return True
+        elif arg.startswith("-Wl,"):
+            ld_args = arg.split(",")[1:]
+            if len(ld_args) == 2 and ld_args[0] == "-rpath":
+                self._handle_rpath(ld_args[1], out)
+                return True
+            else:
+                out.append(arg)
+                return True
+        else:
+            return False
+
+    def _handle_rpath(self, rpath, out):
+        # Filter out all RPATH flags for now and manually add the needed ones
+        # later on.
+        self.rpaths.append(rpath)
+
+    def _handle_print_file_name(self, arg, args, out):
+        if arg == "--print-file-name":
+            print_file_name = next(args)
+        elif arg.startswith("--print-file-name="):
+            print_file_name = arg[len("--print-file-name="):]
+        else:
+            return False
+
+        # Remember print-file-name action. Don't forward to allow for later
+        # manipulation.
+        self.print_file_name = print_file_name
+        self.action = Args.PRINT_FILE_NAME
+
+        return True
+
+    def _handle_compile(self, arg, args, out):
+        if arg == "-c":
+            self.action = Args.COMPILE
+            out.append(arg)
+        else:
+            return False
+
+        return True
+
+
+def load_response_files(args):
+    """Generator that loads arguments from response files.
+
+    Passes through any regular arguments.
+
+    Args:
+      args: Iterable of arguments.
+
+    Yields:
+      All arguments, with response files replaced by their contained arguments.
+
+    """
+    args = iter(args)
+    for arg in args:
+        if arg == "-install_name":
+            # macOS only: The install_name may start with an '@' character.
+            yield arg
+            yield next(args)
+        elif arg.startswith("@"):
+            with open(arg[1:], "r") as rsp:
+                for line in rsp:
+                    for rsp_arg in parse_response_line(line):
+                        yield rsp_arg
+        else:
+            yield arg
+
+
+def parse_response_line(s):
+    # GHC writes response files with quoted lines.
+    return shlex.split(s)
+
+
+def shorten_path(input_path):
+    """Shorten the given path if possible.
+
+    Applies the following transformations if they shorten the path length:
+      - Make path relative to CWD.
+      - Remove redundant up-level references.
+      - Resolve symbolic links.
+
+    Args:
+      input_path: The path to shorten.
+
+    Returns:
+      The shortened path.
+
+    """
+    exists = os.path.exists(input_path)
+    shortened = input_path
+
+    # Try relativizing to current working directory.
+    rel = os.path.relpath(shortened)
+    if len(rel) < len(shortened):
+        shortened = rel
+
+    # Try normalizing the path if possible.
+    norm = os.path.normpath(shortened)
+    if len(norm) < len(shortened):
+        # Ensure that the path is still correct. Reducing up-level references
+        # may change the meaning of the path in the presence of symbolic links.
+        try:
+            if not exists or os.path.samefile(norm, shortened):
+                shortened = norm
+        except IOError:
+            # stat may fail if the path became invalid or does not exist.
+            pass
+
+    # Try resolving symlinks.
+    try:
+        real = os.path.relpath(os.path.realpath(shortened))
+        if len(real) < len(shortened):
+            shortened = real
+    except IOError:
+        # realpath may fail if the path does not exist.
+        pass
+
+    return shortened
+
+
+def rpath_args(rpaths):
+    """Generate arguments for RUNPATHs."""
+    for rpath in rpaths:
+        yield "-Xlinker"
+        yield "-rpath"
+        yield "-Xlinker"
+        yield rpath
+
+
+# --------------------------------------------------------------------
+# Link binary or library
+
+
+def link(output, libraries, rpaths, args):
+    """Execute the link action.
+
+    Args:
+      output: The output binary or library.
+      libraries: Library dependencies.
+      rpaths: The provided rpaths.
+      args: The command-line arguments.
+
+    """
+    if is_darwin():
+        # Reserve space in load commands for later replacement.
+        args.append("-headerpad_max_install_names")
+        rpaths, darwin_rewrites = darwin_shorten_rpaths(
+                rpaths, libraries, output)
+    else:
+        rpaths = shorten_rpaths(rpaths, libraries, output)
+
+    args.extend(rpath_args(rpaths))
+    run_cc(args, exit_on_error=True)
+
+    if is_darwin():
+        darwin_rewrite_load_commands(darwin_rewrites, output)
+
+
+def shorten_rpaths(rpaths, libraries, output):
+    """Avoid redundant rpaths.
+
+    Filters out rpaths that are not required to load any library dependency.
+
+    Args:
+      rpaths: List of given rpaths.
+      libraries: List of library dependencies.
+      output: The output binary, used to resolve rpaths.
+
+    Returns:
+      List of required rpaths.
+
+    """
+    input_rpaths = sort_rpaths(rpaths)
+    missing = set(libraries)
+
+    rpaths = []
+
+    for rpath in input_rpaths:
+        if not missing:
+            break
+        rpath, rpath_dir = resolve_rpath(rpath, output)
+        found, missing = find_library(missing, rpath_dir)
+        if found:
+            rpaths.append(rpath)
+
+    return rpaths
+
+
+def darwin_shorten_rpaths(rpaths, libraries, output):
+    """Avoid redundant rpaths and adapt library load commands.
+
+    Avoids redundant rpaths by detecting the solib directory and making load
+    commands relative to the solib directory where applicable.
+
+    Args:
+      rpaths: List of given rpaths.
+      libraries: List of library dependencies.
+      output: The output binary, used to resolve rpaths.
+
+    Returns:
+      (rpaths, rewrites):
+        rpaths: List of required rpaths.
+        rewrites: List of load command rewrites.
+
+    """
+    input_rpaths = sort_rpaths(rpaths)
+    missing = set(libraries)
+
+    rpaths = []
+    rewrites = []
+
+    # References to core libs take up much space. Consider detecting the GHC
+    # libdir and adding an rpath for that and making load commands relative to
+    # that. Alternatively, https://github.com/bazelbuild/bazel/pull/8888 would
+    # also avoid this issue.
+
+    # Determine solib dir and rewrite load commands relative to solib dir.
+    # This allows to replace potentially many rpaths by one.
+    solib_rpath = find_solib_rpath(input_rpaths, output)
+    if missing and solib_rpath is not None:
+        solib_rpath, solib_dir = resolve_rpath(solib_rpath, output)
+
+        found, missing = find_library_recursive(missing, solib_dir)
+        if found:
+            rpaths.append(solib_rpath)
+            for f in found.values():
+                soname = darwin_get_install_name(os.path.join(solib_dir, f))
+                rewrites.append((soname, f))
+
+    # For the remaining missing libraries, determine which rpaths are required.
+    for rpath in input_rpaths:
+        if not missing:
+            break
+        rpath, rpath_dir = resolve_rpath(rpath, output)
+        found, missing = find_library(missing, rpath_dir)
+        # Libraries with an absolute install_name don't require an rpath entry.
+        found = dict(itertools.filterfalse(
+                lambda item: os.path.isabs(darwin_get_install_name(os.path.join(rpath_dir, item[1]))),
+                found.items()))
+        if len(found) == 1:
+            # Avoid unnecessary rpath if it is only relevant for one load command.
+            [filename] = found.values()
+            soname = darwin_get_install_name(os.path.join(rpath_dir, filename))
+            rewrites.append((soname, os.path.join(rpath, filename)))
+        elif found:
+            rpaths.append(rpath)
+
+    return rpaths, rewrites
+
+
+def sort_rpaths(rpaths):
+    """Sort RUNPATHs by preference.
+
+    Preference in decsending order:
+      - Relative to target
+      - Absolute path
+      - Relative to CWD
+
+    """
+    def rpath_priority(rpath):
+        system = platform.system()
+        if system == "Darwin":
+            if rpath.startswith("@loader_path"):
+                return 0
+        elif system == "Linux":
+            if rpath.startswith("$ORIGIN"):
+                return 0
+        if os.path.isabs(rpath):
+            return 1
+        return 2
+
+    return sorted(rpaths, key=rpath_priority)
+
+
+def find_solib_rpath(rpaths, output):
+    """Find the solib directory rpath entry.
+
+    The solib directory is the directory under which Bazel places dynamic
+    library symbolic links on Unix. It has the form `_solib_<cpu>`.
+
+    """
+    for rpath in rpaths:
+        components = rpath.replace("\\", "/").split("/")
+        solib_rpath = []
+        for comp in components:
+            solib_rpath.append(comp)
+            if comp.startswith("_solib_"):
+                return "/".join(solib_rpath)
+
+    if is_temporary_output(output):
+        # GHC generates temporary libraries outside the execroot. In that case
+        # the Bazel generated RPATHs are not forwarded, and the solib directory
+        # is not visible on the command-line.
+        candidates = glob.glob("**/bin/_solib_*", recursive=True)
+        if candidates:
+            return min(candidates)
+
+    return None
+
+
+def find_library_recursive(libraries, directory):
+    """Find libraries in given directory tree.
+
+    Args:
+      libraries: List of missing libraries.
+      directory: Root of directory tree.
+
+    Returns:
+      (found, missing):
+        found: Dict of found libraries {libname: path} relative to directory.
+        missing: Set of remaining missing libraries.
+
+    """
+    missing = set(libraries)
+    found = {}
+    for root, _, files in os.walk(directory, followlinks=True):
+        prefix = os.path.relpath(root, directory)
+        if not missing:
+            break
+        for f in files:
+            libname = get_lib_name(f)
+            if libname and libname in missing:
+                found[libname] = os.path.join(prefix, f) if prefix != "." else f
+                missing.discard(libname)
+                if not missing:
+                    break
+
+    return found, missing
+
+
+def find_library(libraries, directory):
+    """Find libraries in the given directory.
+
+    Args:
+      libraries: List of missing libraries.
+      directory: The directory in which to search for libraries.
+
+    Returns:
+      (found, missing):
+        found: Dict of found libraries {libname: path} relative to directory.
+        missing: Set of remaining missing libraries.
+
+    """
+    missing = set(libraries)
+    found = {}
+    for _, _, files in itertools.islice(os.walk(directory), 1):
+        if not missing:
+            break
+        for f in files:
+            libname = get_lib_name(f)
+            if libname and libname in missing:
+                found[libname] = f
+                missing.discard(libname)
+
+    return found, missing
+
+
+def get_lib_name(filename):
+    """Determine the library name of the given library file.
+
+    The library name is the name by which the library is referred to in a -l
+    argument to the linker.
+
+    """
+    if not filename.startswith("lib"):
+        return None
+
+    libname = filename[3:]
+    dotsodot = libname.find(".so.")
+    if dotsodot != -1:
+        return libname[:dotsodot]
+
+    libname, ext = os.path.splitext(libname)
+    if ext in [".dll", ".dylib", ".so"]:
+        return libname
+
+    return None
+
+
+def resolve_rpath(rpath, output):
+    """Resolve the given rpath, replacing references to the binary."""
+    def has_origin(rpath):
+        return rpath.startswith("$ORIGIN") or rpath.startswith("@loader_path")
+
+    def replace_origin(rpath, origin):
+        rpath = rpath.replace("$ORIGIN/", origin)
+        rpath = rpath.replace("$ORIGIN", origin)
+        rpath = rpath.replace("@loader_path/", origin)
+        rpath = rpath.replace("@loader_path", origin)
+        return rpath
+
+    if is_temporary_output(output):
+        # GHC generates temporary libraries outside the execroot. The regular
+        # relative rpaths don't work in that case and have to be converted to
+        # absolute paths.
+        if has_origin(rpath):
+            # We don't know what $ORIGIN/@loader_path was meant to refer to.
+            # Try to find an existing, matching rpath by globbing.
+            stripped = replace_origin(rpath, "")
+            candidates = glob.glob(os.path.join("**", stripped), recursive=True)
+            if not candidates:
+                # Path does not exist. It will be sorted out later, since no
+                # library will be found underneath it.
+                rpath = stripped
+            else:
+                rpath = os.path.abspath(shorten_path(min(candidates)))
+        else:
+            rpath = os.path.abspath(shorten_path(rpath))
+
+        return rpath, rpath
+    else:
+        # Consider making relative rpaths relative to output.
+        #   E.g. bazel-out/.../some/dir to @loader_path/.../some/dir
+        outdir = os.path.dirname(output) + "/"
+        resolved = replace_origin(rpath, outdir)
+        return rpath, resolved
+
+
+def darwin_get_install_name(lib):
+    """Read the install_name of the given library."""
+    lines = subprocess.check_output([OTOOL, "-D", lib]).splitlines()
+    if len(lines) >= 2:
+        return lines[1]
+    else:
+        return os.path.basename(lib)
+
+
+def darwin_rewrite_load_commands(rewrites, output):
+    """Rewrite the load commands in the given binary."""
+    args = []
+    for old, new in rewrites:
+        args.extend(["-change", old, os.path.join("@rpath", new)])
+    if args:
+        subprocess.check_call([INSTALL_NAME_TOOL] + args + [output])
+
+
+# --------------------------------------------------------------------
+# print-file-name
+
+
+def print_file_name(filename, args):
+    """Execute the print-file-name action.
+
+    Args:
+      filename: The queried filename.
+      args: The remaining arguments.
+
+    """
+    (basename, ext) = os.path.splitext(filename)
+    if is_darwin() and ext == ".dylib":
+        # Bazel generates dynamic libraries with .so extension on Darwin.
+        # However, GHC only looks for files with .dylib extension.
+
+        # Try with the .dylib extension first.
+        found, res = run_cc_print_file_name(filename, args)
+        if not found:
+            # Retry with .so extension.
+            found, so_res = run_cc_print_file_name("%s.so" % basename, args)
+            if found:
+                res = so_res
+    else:
+        _, res = run_cc_print_file_name(filename, args)
+
+    sys.stdout.write(res.stdout.decode())
+    sys.stderr.write(res.stderr.decode())
+    sys.exit(res.returncode)
+
+
+def run_cc_print_file_name(filename, args):
+    """Run cc --print-file-name on the given file name.
+
+    Args:
+      filename: The filename to query for.
+      args: Remaining command-line arguments. Relevant for -B flags.
+
+    Returns:
+      filename, res:
+        filename: The returned filename, if it exists, otherwise None.
+        res: CompletedProcess
+
+    """
+    args = args + ["--print-file-name", filename]
+    res = run_cc(args, capture_output=True, exit_on_error=True)
+    filename = res.stdout.decode().strip()
+    # Note, gcc --print-file-name does not fail if the file was not found, but
+    # instead just returns the input filename.
+    if os.path.isfile(filename):
+        return filename, res
+    else:
+        return None, res
+
+
+# --------------------------------------------------------------------
+
+
+def run_cc(args, capture_output=False, exit_on_error=False, **kwargs):
+    """Execute cc with a response file holding the given arguments.
+
+    Args:
+      args: Iterable of arguments to pass to cc.
+      capture_output: Whether to capture stdout and stderr.
+      exit_on_error: Whether to exit on error. Will print captured output first.
+
+    Returns:
+      CompletedProcess
+
+    """
+    if capture_output:
+        # The capture_output argument to subprocess.run was only added in 3.7.
+        new_kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+        new_kwargs.update(kwargs)
+        kwargs = new_kwargs
+
+    if os.path.isfile(CC):
+        cc = CC
+    else:
+        # On macOS CC is a relative path to a wrapper script. If we're
+        # being called from a GHCi REPL then we need to find this wrapper
+        # script using Bazel runfiles.
+        r = bazel_runfiles.Create()
+        cc = r.Rlocation("/".join([WORKSPACE, CC]))
+        if cc is None and platform.system() == "Windows":
+            # We must use "/" instead of os.path.join on Windows, because the
+            # Bazel runfiles_manifest file uses "/" separators.
+            cc = r.Rlocation("/".join([WORKSPACE, CC + ".exe"]))
+        if cc is None:
+            print("CC not found '{}'.".format(CC), file=sys.stderr)
+            sys.exit(1)
+
+    with response_file(args) as rsp:
+        res = subprocess.run([cc, "@" + rsp], **kwargs)
+
+    if exit_on_error and res.returncode != 0:
+        if capture_output:
+            sys.stdout.write(res.stdout.decode())
+            sys.stderr.write(res.stderr.decode())
+        sys.exit(res.returncode)
+
+    return res
+
+
+@contextmanager
+def response_file(args):
+    """Create a response file for the given arguments.
+
+    Context manager, use in a with statement. The file will be deleted at the
+    end of scope.
+
+    Args:
+      args: Iterable, the arguments to write in to the response file.
+
+    Yields:
+      The file name of the response file.
+
+    """
+    try:
+        with tempfile.NamedTemporaryFile(mode="w", prefix="rsp", delete=False) as f:
+            for arg in args:
+                line = generate_response_line(arg)
+                f.write(line)
+            f.close()
+            yield f.name
+    finally:
+        try:
+            os.remove(f.name)
+        except OSError:
+            pass
+
+
+def generate_response_line(arg):
+    # Gcc expects one argument per line, surrounded by double quotes, with
+    # inner double quotes escaped with backslash, and backslashes themselves
+    # escaped. shlex.quote conflicts with this format.
+    return '"{}"\n'.format(arg.replace("\\", "\\\\").replace('"', '\\"'))
+
+
+def is_darwin():
+    """Whether the execution platform is Darwin."""
+    return platform.system() == "Darwin"
+
+
+def is_temporary_output(output):
+    """Whether the target is temporary.
+
+    GHC generates temporary libraries in certain cases related to Template
+    Haskell outside the execroot. This means that rpaths relative to $ORIGIN or
+    @loader_path are going to be invalid.
+
+    """
+    # Assumes that the temporary directory is set to an absolute path, while
+    # the outputs under the execroot are referred to by relative path. This
+    # should be a valid assumption as the temporary directory needs to be
+    # available irrespective of the current working directory, while Bazel uses
+    # paths relative to the execroot to avoid things like user names creeping
+    # into cache keys. If this turns out to be wrong we could instead look for
+    # path components matching Bazel's output directory hierarchy.
+    # See https://docs.bazel.build/versions/master/output_directories.html
+    return os.path.isabs(output)
+
+
+# --------------------------------------------------------------------
+
+
+if __name__ == "__main__":
+    main()
+
+
+# vim: ft=python
diff --git a/haskell/private/ghci_repl_wrapper.sh b/haskell/private/ghci_repl_wrapper.sh
index cd6acef..f672671 100644
--- a/haskell/private/ghci_repl_wrapper.sh
+++ b/haskell/private/ghci_repl_wrapper.sh
@@ -54,6 +54,11 @@ cd "$BUILD_WORKSPACE_DIRECTORY"
 
 RULES_HASKELL_EXEC_ROOT=$(dirname $(readlink ${BUILD_WORKSPACE_DIRECTORY}/bazel-out))
 TOOL_LOCATION="$RULES_HASKELL_EXEC_ROOT/{TOOL}"
+# Setting -pgm* flags explicitly has the unfortunate side effect
+# of resetting any program flags in the GHC settings file. So we
+# restore them here. See
+# https://ghc.haskell.org/trac/ghc/ticket/7929.
+PGM_ARGS="-pgma {CC} -pgmc {CC} -pgml {CC} -pgmP {CC} -optc-fno-stack-protector -optP-E -optP-undef -optP-traditional"
 
 {ENV}
-"$TOOL_LOCATION" {ARGS} "$@"
+"$TOOL_LOCATION" $PGM_ARGS {ARGS} "$@"
diff --git a/haskell/private/osx_cc_wrapper.sh.tpl b/haskell/private/osx_cc_wrapper.sh.tpl
deleted file mode 100644
index 9abf9ce..0000000
--- a/haskell/private/osx_cc_wrapper.sh.tpl
+++ /dev/null
@@ -1,313 +0,0 @@
-#!/bin/bash
-#
-# Copyright 2015 The Bazel Authors. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# This is a wrapper script around gcc/clang that adjusts linker flags for
-# Haskell library and binary targets.
-#
-# Load commands that attempt to load dynamic libraries relative to the working
-# directory in their package output path (bazel-out/...) are converted to load
-# commands relative to @rpath. rules_haskell passes the corresponding
-# -Wl,-rpath,... flags itself.
-#
-# rpath commands that attempt to add rpaths relative to the working directory
-# to look for libraries in their package output path (bazel-out/...) are
-# omitted, since rules_haskell adds more appropriate rpaths itself.
-#
-# GHC generates intermediate dynamic libraries outside the build tree.
-# Additional RPATH entries are provided for those to make dynamic library
-# dependencies in the Bazel build tree available at runtime.
-#
-# See https://blogs.oracle.com/dipol/entry/dynamic_libraries_rpath_and_mac
-# on how to set those paths for Mach-O binaries.
-#
-set -euo pipefail
-
-INSTALL_NAME_TOOL="/usr/bin/install_name_tool"
-OTOOL="/usr/bin/otool"
-
-# Collect arguments to forward in a fresh response file.
-RESPONSE_FILE="$(mktemp osx_cc_args_XXXX.rsp)"
-rm_response_file() {
-    rm -f "$RESPONSE_FILE"
-}
-trap rm_response_file EXIT
-
-add_args() {
-   # Add the given arguments to the fresh response file. We follow GHC's
-   # example in storing one argument per line, wrapped in double quotes. Double
-   # quotes in the argument itself are escaped.
-   for arg in "$@"; do
-       printf '"%s"\n' "${arg//\"/\\\"}" >> "$RESPONSE_FILE"
-   done
-}
-
-# Collect library, library dir, and rpath arguments.
-LIBS=()
-LIB_DIRS=()
-RPATHS=()
-
-# Parser state.
-# Parsing response file - unquote arguments.
-QUOTES=
-# Upcoming linker argument.
-LINKER=
-# Upcoming rpath argument.
-RPATH=
-# Upcoming install-name argument.
-INSTALL=
-# Upcoming output argument.
-OUTPUT=
-
-parse_arg() {
-    # Parse the given argument. Decide whether to pass it on to the compiler,
-    # and how it affects the parser state.
-    local arg="$1"
-    # Unquote response file arguments.
-    if [[ "$QUOTES" = "1" && "$arg" =~ ^\"(.*)\"$ ]]; then
-        # Take GHC's argument quoting into account when parsing a response
-        # file. Note, no indication was found that GHC would pass multiline
-        # arguments, or insert escape codes into the quoted arguments. If you
-        # observe ill-formed arguments being passed to the compiler, then this
-        # logic may need to be extended.
-        arg="${BASH_REMATCH[1]}"
-    fi
-    # Parse given argument.
-    if [[ "$OUTPUT" = "1" ]]; then
-        # The previous argument was -o. Read output file.
-        OUTPUT="$arg"
-        add_args "$arg"
-    elif [[ "$LINKER" = "1" ]]; then
-        # The previous argument was -Xlinker. Read linker argument.
-        if [[ "$RPATH" = "1" ]]; then
-            # The previous argument was -rpath. Read RPATH.
-            parse_rpath "$arg"
-            RPATH=0
-        elif [[ "$arg" = "-rpath" ]]; then
-            # rpath is coming
-            RPATH=1
-        else
-            # Unrecognized linker argument. Pass it on.
-            add_args "-Xlinker" "$arg"
-        fi
-        LINKER=
-    elif [[ "$INSTALL" = "1" ]]; then
-        INSTALL=
-        add_args "$arg"
-    elif [[ "$arg" =~ ^@(.*)$ ]]; then
-        # Handle response file argument. Parse the arguments contained in the
-        # response file one by one. Take GHC's argument quoting into account.
-        # Note, assumes that response file arguments are not nested in other
-        # response files.
-        QUOTES=1
-        while read line; do
-            parse_arg "$line"
-        done < "${BASH_REMATCH[1]}"
-        QUOTES=
-    elif [[ "$arg" = "-install_name" ]]; then
-        # Install name is coming. We don't use it, but it can start with an @
-        # and be mistaken for a response file.
-        INSTALL=1
-        add_args "$arg"
-    elif [[ "$arg" = "-o" ]]; then
-        # output is coming
-        OUTPUT=1
-        add_args "$arg"
-    elif [[ "$arg" = "-Xlinker" ]]; then
-        # linker flag is coming
-        LINKER=1
-    elif [[ "$arg" =~ ^-l(.*)$ ]]; then
-        LIBS+=("${BASH_REMATCH[1]}")
-        add_args "$arg"
-    elif [[ "$arg" =~ ^-L(.*)$ ]]; then
-        LIB_DIRS+=("${BASH_REMATCH[1]}")
-        add_args "$arg"
-    elif [[ "$arg" =~ ^-Wl,-rpath,(.*)$ ]]; then
-        parse_rpath "${BASH_REMATCH[1]}"
-    else
-        # Unrecognized argument. Pass it on.
-        add_args "$arg"
-    fi
-}
-
-parse_rpath() {
-    # Parse the given -rpath argument and decide whether it should be
-    # forwarded to the compiler/linker.
-    local rpath="$1"
-    if [[ "$rpath" =~ ^/ || "$rpath" =~ ^@ ]]; then
-        # Absolute rpaths or rpaths relative to @loader_path or similar, are
-        # passed on to the linker. Other relative rpaths are dropped, these
-        # are auto-generated by GHC, but are useless because rules_haskell
-        # constructs dedicated rpaths to the _solib or _hssolib directory.
-        # See https://github.com/tweag/rules_haskell/issues/689
-        add_args "-Wl,-rpath,$rpath"
-        RPATHS+=("$rpath")
-    fi
-}
-
-# Parse all given arguments.
-for arg in "$@"; do
-    parse_arg "$arg"
-done
-
-get_library_in() {
-    # Find the given library in the given directory.
-    # Returns empty string if the library is not found.
-    local lib="$1"
-    local dir="$2"
-    local solib="${dir}${dir:+/}lib${lib}.so"
-    local dylib="${dir}${dir:+/}lib${lib}.dylib"
-    if [[ -f "$solib" ]]; then
-        echo "$solib"
-    elif [[ -f "$dylib" ]]; then
-        echo "$dylib"
-    fi
-}
-
-get_library_path() {
-    # Find the given library in the specified library search paths.
-    # Returns empty string if the library is not found.
-    if [[ ${#LIB_DIRS[@]} -gt 0 ]]; then
-        local libpath
-        for libdir in "${LIB_DIRS[@]}"; do
-            libpath="$(get_library_in "$1" "$libdir")"
-            if [[ -n "$libpath" ]]; then
-                echo "$libpath"
-                return
-            fi
-        done
-    fi
-}
-
-resolve_rpath() {
-    # Resolve the given rpath. I.e. if it is an absolute path, just return it.
-    # If it is relative to the output, then prepend the output path.
-    local rpath="$1"
-    if [[ "$rpath" =~ ^/ ]]; then
-        echo "$rpath"
-    elif [[ "$rpath" =~ ^@loader_path/(.*)$ || "$rpath" =~ ^@executable_path/(.*)$ ]]; then
-        echo "$(dirname "$OUTPUT")/${BASH_REMATCH[1]}"
-    else
-        echo "$rpath"
-    fi
-}
-
-get_library_rpath() {
-    # Find the given library in the specified rpaths.
-    # Returns empty string if the library is not found.
-    if [[ ${#RPATHS[@]} -gt 0 ]]; then
-        local libdir libpath
-        for rpath in "${RPATHS[@]}"; do
-            libdir="$(resolve_rpath "$rpath")"
-            libpath="$(get_library_in "$1" "$libdir")"
-            if [[ -n "$libpath" ]]; then
-                echo "$libpath"
-                return
-            fi
-        done
-    fi
-}
-
-get_library_name() {
-    # Get the "library name" of the given library.
-    "$OTOOL" -D "$1" | tail -1
-}
-
-relpath() {
-    # Find relative path from the first to the second path. Assuming the first
-    # is a directory. If either is an absolute path, then we return the
-    # absolute path to the second.
-    local from="$1"
-    local to="$2"
-    if [[ "$to" =~ ^/ ]]; then
-        echo "$to"
-    elif [[ "$from" =~ ^/ ]]; then
-        echo "$PWD/$to"
-    else
-        # Split path and store components in bash array.
-        IFS=/ read -a fromarr <<<"$from"
-        IFS=/ read -a toarr <<<"$to"
-        # Drop common prefix.
-        for ((i=0; i < ${#fromarr[@]}; ++i)); do
-            if [[ "${fromarr[$i]}" != "${toarr[$i]}" ]]; then
-                break
-            fi
-        done
-        # Construct relative path.
-        local common=$i
-        local out=
-        for ((i=$common; i < ${#fromarr[@]}; ++i)); do
-            out="$out${out:+/}.."
-        done
-        for ((i=$common; i < ${#toarr[@]}; ++i)); do
-            out="$out${out:+/}${toarr[$i]}"
-        done
-        echo $out
-    fi
-}
-
-generate_rpath() {
-    # Generate an rpath entry for the given library path.
-    local rpath="$(relpath "$(dirname "$OUTPUT")" "$(dirname "$1")")"
-    if [[ "$rpath" =~ ^/ ]]; then
-        echo "$rpath"
-    else
-        # Relative rpaths are relative to the binary.
-        echo "@loader_path${rpath:+/}$rpath"
-    fi
-}
-
-if [[ ! "$OUTPUT" =~ ^bazel-out/ && ${#LIBS[@]} -gt 0 ]]; then
-    # GHC generates temporary dynamic libraries during compilation outside of
-    # the build directory. References to dynamic C libraries are broken in this
-    # case. Here we add additional RPATHs to fix these references. The Hazel
-    # package for swagger2 is an example that triggers this issue.
-    for lib in "${LIBS[@]}"; do
-        librpath="$(get_library_rpath "$lib")"
-        if [[ -z "$librpath" ]]; then
-            # The given library was not found in any of the rpaths.
-            # Find it in the library search paths.
-            libpath="$(get_library_path "$lib")"
-            if [[ "$libpath" =~ ^bazel-out/ ]]; then
-                # The library is Bazel generated and loaded relative to PWD.
-                # Add an RPATH entry, so it is found at runtime.
-                rpath="$(generate_rpath "$libpath")"
-                parse_rpath "$rpath"
-            fi
-        fi
-    done
-fi
-
-# Call the C++ compiler with the fresh response file.
-%{cc} "@$RESPONSE_FILE"
-
-if [[ ${#LIBS[@]} -gt 0 ]]; then
-    # Replace load commands relative to the working directory, by load commands
-    # relative to the rpath, if the library can be found relative to an rpath.
-    for lib in "${LIBS[@]}"; do
-        librpath="$(get_library_rpath "$lib")"
-        if [[ -n "$librpath" ]]; then
-            libname="$(get_library_name "$librpath")"
-            if [[ "$libname" =~ ^bazel-out/ ]]; then
-                "${INSTALL_NAME_TOOL}" -change \
-                    "$libname" \
-                    "@rpath/$(basename "$librpath")" \
-                    "$OUTPUT"
-            fi
-        fi
-    done
-fi
-
-# vim: ft=sh
diff --git a/haskell/providers.bzl b/haskell/providers.bzl
index 482cea7..9c6e1d5 100644
--- a/haskell/providers.bzl
+++ b/haskell/providers.bzl
@@ -174,7 +174,7 @@ def _get_unique_lib_files(cc_info):
         for filename in filenames
     ]
 
-def get_ghci_extra_libs(hs, cc_info, dynamic = True, path_prefix = None):
+def get_ghci_extra_libs(hs, cc_info, path_prefix = None):
     """Get libraries appropriate for GHCi's linker.
 
     GHC expects dynamic and static versions of the same library to have the
@@ -185,16 +185,12 @@ def get_ghci_extra_libs(hs, cc_info, dynamic = True, path_prefix = None):
     directory to allow for less RPATH entries and to fix file extensions that
     GHCi does not support.
 
-    GHCi can load PIC static libraries (-fPIC -fexternal-dynamic-refs) and
-    dynamic libraries. Preferring static libraries can be useful to reduce the
-    risk of exceeding the MACH-O header size limit on macOS, and to reduce
-    build times by avoiding to generate dynamic libraries. However, this
-    requires GHCi to run with the statically linked rts library.
+    GHCi can load PIC static libraries (-fPIC -fexternal-dynamic-refs) with a
+    dynamic RTS and dynamic libraries with a dynamic RTS.
 
     Args:
       hs: Haskell context.
       cc_info: Combined CcInfo provider of dependencies.
-      dynamic: (optional) Whether to prefer dynamic libraries.
       path_prefix: (optional) Prefix for the entries in the generated library path.
 
     Returns:
@@ -206,7 +202,7 @@ def get_ghci_extra_libs(hs, cc_info, dynamic = True, path_prefix = None):
     (static_libs, dynamic_libs) = get_extra_libs(
         hs,
         cc_info,
-        dynamic = dynamic,
+        dynamic = not hs.toolchain.is_static,
         pic = True,
         fixup_dir = "_ghci_libs",
     )
@@ -266,8 +262,6 @@ def get_extra_libs(hs, cc_info, dynamic = False, pic = None, fixup_dir = "_libs"
         elif lib_to_link.static_library and not pic_required:
             static_lib = lib_to_link.static_library
 
-        if dynamic_lib:
-            dynamic_lib = symlink_dynamic_library(hs, dynamic_lib, fixed_lib_dir)
         static_lib = mangle_static_library(hs, dynamic_lib, static_lib, fixed_lib_dir)
 
         if static_lib and not (dynamic and dynamic_lib):
diff --git a/haskell/repl.bzl b/haskell/repl.bzl
index b05aaba..50bad3a 100644
--- a/haskell/repl.bzl
+++ b/haskell/repl.bzl
@@ -283,6 +283,7 @@ def _create_repl(hs, ctx, repl_info, output):
         substitutions = {
             "{ENV}": render_env(dicts.add(hs.env, ghc_env)),
             "{TOOL}": hs.tools.ghci.path,
+            "{CC}": hs.toolchain.cc_wrapper.executable.path,
             "{ARGS}": " ".join(
                 args + [
                     shell.quote(a)
@@ -306,6 +307,8 @@ def _create_repl(hs, ctx, repl_info, output):
                 depset([hs.toolchain.locale_archive] if hs.toolchain.locale_archive else []),
             ]),
             collect_data = ctx.attr.collect_data,
+        ).merge(
+            hs.toolchain.cc_wrapper.runfiles,
         ),
     )]
 
diff --git a/haskell/toolchain.bzl b/haskell/toolchain.bzl
index 1ab0c07..d1ae9b0 100644
--- a/haskell/toolchain.bzl
+++ b/haskell/toolchain.bzl
@@ -24,29 +24,27 @@ def _run_ghc(hs, cc, inputs, outputs, mnemonic, arguments, params_file = None, e
     args = hs.actions.args()
     args.add(hs.tools.ghc)
 
-    # Do not use Bazel's CC toolchain on Windows, as it leads to linker and librarty compatibility issues.
     # XXX: We should also tether Bazel's CC toolchain to GHC's, so that we can properly mix Bazel-compiled
     # C libraries with Haskell targets.
-    if not hs.toolchain.is_windows:
-        args.add_all([
-            # GHC uses C compiler for assemly, linking and preprocessing as well.
-            "-pgma",
-            cc.tools.cc,
-            "-pgmc",
-            cc.tools.cc,
-            "-pgml",
-            cc.tools.cc,
-            "-pgmP",
-            cc.tools.cc,
-            # Setting -pgm* flags explicitly has the unfortunate side effect
-            # of resetting any program flags in the GHC settings file. So we
-            # restore them here. See
-            # https://ghc.haskell.org/trac/ghc/ticket/7929.
-            "-optc-fno-stack-protector",
-            "-optP-E",
-            "-optP-undef",
-            "-optP-traditional",
-        ])
+    args.add_all([
+        # GHC uses C compiler for assemly, linking and preprocessing as well.
+        "-pgma",
+        cc.tools.cc,
+        "-pgmc",
+        cc.tools.cc,
+        "-pgml",
+        cc.tools.cc,
+        "-pgmP",
+        cc.tools.cc,
+        # Setting -pgm* flags explicitly has the unfortunate side effect
+        # of resetting any program flags in the GHC settings file. So we
+        # restore them here. See
+        # https://ghc.haskell.org/trac/ghc/ticket/7929.
+        "-optc-fno-stack-protector",
+        "-optP-E",
+        "-optP-undef",
+        "-optP-traditional",
+    ])
 
     compile_flags_file = hs.actions.declare_file("compile_flags_%s_%s" % (hs.name, mnemonic))
     extra_args_file = hs.actions.declare_file("extra_args_%s_%s" % (hs.name, mnemonic))
@@ -65,6 +63,9 @@ def _run_ghc(hs, cc, inputs, outputs, mnemonic, arguments, params_file = None, e
         extra_args_file,
     ] + cc.files
 
+    if hs.toolchain.locale_archive != None:
+        extra_inputs.append(hs.toolchain.locale_archive)
+
     if params_file:
         params_file_src = params_file.path
         extra_inputs.append(params_file)
@@ -96,6 +97,11 @@ set -o pipefail
     else:
         inputs += extra_inputs
 
+    if input_manifests != None:
+        input_manifests = input_manifests + cc.manifests
+    else:
+        input_manifests = cc.manifests
+
     hs.actions.run_shell(
         inputs = inputs,
         input_manifests = input_manifests,
@@ -176,6 +182,12 @@ fi
         for lib in ctx.attr.libraries
     }
 
+    (cc_wrapper_inputs, cc_wrapper_manifest) = ctx.resolve_tools(tools = [ctx.attr._cc_wrapper])
+    cc_wrapper_info = ctx.attr._cc_wrapper[DefaultInfo]
+    cc_wrapper_runfiles = cc_wrapper_info.default_runfiles.merge(
+        cc_wrapper_info.data_runfiles,
+    )
+
     return [
         platform_common.ToolchainInfo(
             name = ctx.label.name,
@@ -185,7 +197,12 @@ fi
             haddock_flags = ctx.attr.haddock_flags,
             locale = ctx.attr.locale,
             locale_archive = locale_archive,
-            osx_cc_wrapper_tpl = ctx.file._osx_cc_wrapper_tpl,
+            cc_wrapper = struct(
+                executable = ctx.executable._cc_wrapper,
+                inputs = cc_wrapper_inputs,
+                manifests = cc_wrapper_manifest,
+                runfiles = cc_wrapper_runfiles,
+            ),
             mode = ctx.var["COMPILATION_MODE"],
             actions = struct(
                 compile_binary = compile_binary,
@@ -254,9 +271,10 @@ _haskell_toolchain = rule(
 Label pointing to the locale archive file to use. Mostly useful on NixOS.
 """,
         ),
-        "_osx_cc_wrapper_tpl": attr.label(
-            allow_single_file = True,
-            default = Label("@io_tweag_rules_haskell//haskell:private/osx_cc_wrapper.sh.tpl"),
+        "_cc_wrapper": attr.label(
+            cfg = "host",
+            default = Label("@io_tweag_rules_haskell//haskell:cc_wrapper"),
+            executable = True,
         ),
     },
 )
